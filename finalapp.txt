import os
import json
import time
import sys
from dotenv import load_dotenv
import google.generativeai as genai
from google.api_core import exceptions
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS

# 1. LOAD ENVIRONMENT VARIABLES
load_dotenv()

# Configure Flask to serve static files from 'templates'
app = Flask(__name__, static_folder='templates', template_folder='templates')
CORS(app)

# 2. SECURELY GET API KEY
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    print("❌ WARNING: API Key not found! Check your .env file.")

if api_key:
    genai.configure(api_key=api_key)

# 3. MASSIVE ROUND ROBIN MODEL ROSTER
MODEL_ROSTER = [
    # --- TIER 1: HIGH SPEED & STABLE FLASH ---
    'models/gemini-2.0-flash',
    'models/gemini-2.0-flash-001',
    'models/gemini-flash-latest',
    'models/gemini-flash-lite-latest',
    'models/gemini-2.5-flash',
    'models/gemini-2.5-flash-lite',
    
    # --- TIER 2: NEXT GEN (2.5) ---
    'models/gemini-2.5-flash-preview-09-2025',
    'models/gemini-2.5-flash-lite-preview-09-2025',
    
    # --- TIER 3: HIGH INTELLIGENCE PRO MODELS ---
    'models/gemini-2.5-pro',
    'models/gemini-pro-latest',
    'models/gemini-3-pro-preview',
    'models/deep-research-pro-preview-12-2025',
    
    # --- TIER 4: LIGHTWEIGHT / PREVIEW ---
    'models/gemini-2.0-flash-lite',
    'models/gemini-2.0-flash-lite-001',
    'models/gemini-2.0-flash-lite-preview',
    'models/gemini-2.0-flash-lite-preview-02-05',
    
    # --- TIER 5: EXPERIMENTAL ---
    'models/gemini-2.0-flash-exp',
    'models/gemini-exp-1206',
    
    # --- TIER 6: GEMMA (OPEN MODELS FALLBACK) ---
    'models/gemma-3-27b-it',
    'models/gemma-3-12b-it',
    'models/gemma-3-4b-it',
    'models/gemma-3-1b-it',
    'models/gemma-3n-e4b-it',
    'models/gemma-3n-e2b-it',
    
    # --- TIER 7: OBSCURE PREVIEWS (LAST RESORT) ---
    'models/nano-banana-pro-preview' 
]

@app.route('/')
def home():
    return render_template('index.html')

# --- NEW: AI CHAT ASSISTANT ROUTE ---
@app.route('/ai_chat', methods=['POST'])
def ai_chat():
    try:
        data = request.json
        user_message = data.get('message', '')
        current_code = data.get('code_context', '')
        
        if not user_message:
            return jsonify({"status": "error", "message": "No message provided"}), 400

        # Chat Prompt - Helpful Assistant
        prompt = f"""
        ACT AS: An Expert AI Coding Assistant for the CodeStatic platform.
        YOUR GOAL: Help the user understand logic, syntax, or concepts. Be concise, friendly, and accurate. Use **only** standard Markdown (like bold, italics, code blocks, or lists) for formatting. DO NOT use special Unicode symbols, emojis, or custom stylistic characters.
        
        USER'S CURRENT CODE CONTEXT (For reference only):
        ```{current_code}```
        
        USER QUESTION: "{user_message}"
        
        RESPONSE: Provide a direct, helpful answer.
        """
        
        # Simple Round Robin for Chat
        for model_name in MODEL_ROSTER:
            try:
                current_model = genai.GenerativeModel(model_name)
                response = current_model.generate_content(prompt)
                return jsonify({"status": "success", "reply": response.text})
            except:
                continue 
        
        return jsonify({"status": "error", "message": "AI services busy."})

    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/process_code', methods=['POST'])
def process_code():
    try:
        data = request.json
        source_code = data.get('code', '')
        target_lang = data.get('target_lang', '')
        
        if not source_code or not target_lang:
            return jsonify({"status": "error", "message": "Missing code or target language"}), 400

        # Pre-numbering strategy
        lines = source_code.split('\n')
        numbered_code = "\n".join([f"{i+1} | {line}" for i, line in enumerate(lines)])

        # HR Prompt - SUPREME CODE ARCHITECT
        # UPDATED PROMPT: Added instruction for Quality Score and Plagiarism Check
        prompt = f"""
        ACT AS: The "Supreme Code Architect" and Forensic Debugger.
        TASK: Perform a deep-scan code audit, ruthlessly identify ALL errors, and generate a 100% CORRECT, COMPILABLE solution in {target_lang}.
        
        *** CRITICAL INSTRUCTION ON LINE NUMBERS ***
        The "CANDIDATE INPUT CODE" provided below is PRE-NUMBERED (Format: "LineNumber | Code").
        Use the EXPLICIT line number printed at the start of the line for the error table.
        
        CANDIDATE INPUT CODE:
        ```{numbered_code}```
        
        TARGET LANGUAGE: {target_lang}
        
        MANDATORY VALIDATION PROTOCOLS (23-POINT CHECK SYSTEM):
        Scan every line against these 23 specific error categories.
        
        1. **SYNTAX & COMPILATION (CRITICAL)**
           - Semicolons, Brackets, Typos.
        2. **LOGIC & SEMANTIC ERRORS**
           - Infinite Loops, Unreachable Code, Bad Assignments.
        3. **TYPE & CASTING ERRORS**
        4. **RUNTIME & EXCEPTION PREDICTION**
           - Null Pointer, Division by Zero.
        5. **LINKER & API ERRORS**
           - Missing Imports, Wrong Signatures.
        6. **MEMORY & RESOURCE MANAGEMENT**
           - Leaks, Unclosed Files.
        7. **OOP INTEGRITY**
           - Encapsulation, Inheritance, Class Structure.
        8. **DSA INTEGRITY (Data Structures)**
           - Linked Lists, Arrays (Bounds), Stacks.
        9. **SECURITY RISKS**
           - Buffer Overflow, Injection, Secrets.
        10. **CONCURRENCY (Thread Safety)**
        11. **I/O & FILE HANDLING**
        12. **CONFIGURATION & ENVIRONMENT**
            - Global Namespace Pollution.
        13. **MATH & ALGORITHMIC ACCURACY**
        14. **INTENT vs IMPLEMENTATION**
        15. **MANDATORY INDENTATION (Python Only)**
        16. **Database Errors**
        17. **Exception Handling (Empty catch)**
        18. **Hardware/Driver Issues**
        19. **Network Socket Failures**
        20. **Deprecated API Usage**
        21. **Race Conditions**
        22. **Floating Point Precision**
        23. **Misleading Comments**
        
        INSTRUCTIONS:
        1. **DETECT**: Identify source language.
        2. **ASSESS (Forensic Scan)**: 
           - **MENTAL COMPILATION**: Mentally compile the code. 
           - **ERROR MAPPING**: Populate the `error_table` with EVERY SINGLE issue found.
           - **Score**: Assign a strict quality score to the *INPUT* code (likely low) from 0 to 100.
           - **Plagiarism**: SIMULATE a check against known online solutions. Set `plagiarism_check` to: "High Match (e.g., LeetCode/GFG solution)" if the code is structured like a direct copy, or "Low Match (Original Logic)" otherwise.
        
        3. **MANDATORY PRE-FLIGHT CHECK (Internal)**:
           - "Does this code solve all 23 checklist items?"
           - "Is the fixed code translated correctly to {target_lang}?"
           - "Is the score of my fixed code 95/100 or higher?"
           - If NO, refine it immediately until it is perfect.
        
        4. **FIX (Supreme Correction & TRANSLATION - Target 100/100)**: 
           - **MANDATORY TRANSLATION**: The `final_code` MUST be written in **{target_lang}**.
           - Rewrite the code to be **100% ERROR-FREE**.
           - The fixed code MUST address EVERY item in the checklist above.
           - **Guarantee**: The result must compile and run immediately without modification.
           - Add ALL missing imports/headers.
           - Fix ALL logic.
        
        5. **EXPLAIN (STRICT FILTERING)**: 
           - Provide a line-by-line explanation of the **FIXED FINAL CODE**.
           - **STRICT EXCLUSION RULE**: Do NOT generate an explanation object for:
             a. Lines that are empty or whitespace only.
             b. Lines that contain ONLY comments (starting with //, #, /*).
             c. Lines that contain ONLY closing braces '}}' or keywords like 'end' (unless critical logic).
           - **CRITICAL**: The 'code' field MUST contain the ACTUAL CODE SNIPPET from the 'final_code'.
           - Explain *what* the code does and *why* specific fixes were made.
        
        6. **COMPLEXITY**: 
           - Analyze Best, Average, and Worst Case Time Complexity.
           - Analyze Best, Average, and Worst Case Space Complexity.
        
        OUTPUT FORMAT (Strict JSON):
        {{
            "detected_language": "String",
            "quality_score": Integer,
            "integrity_check": "String (Summary of critical failures found in original code)",
            "plagiarism_check": "String (e.g., 'Low Match (Original Logic)' or 'High Match (e.g., LeetCode/GFG solution)')", 
            "error_table": [ {{ "line": 5, "error": "Detailed error description" }} ],
            "final_code": "String (The 100% CORRECTED, COMPLETE, and COMPILABLE code in {target_lang})",
            "code_explanation": [ 
                {{ "line": 1, "code": "import os", "explanation": "Imports standard library..." }},
                {{ "line": 5, "code": "x = 10", "explanation": "Initializes variable..." }}
            ],
            "complexity": {{
                "time": {{ "best": "O(1)", "average": "O(n)", "worst": "O(n)", "desc": "Explanation..." }},
                "space": {{ "best": "O(1)", "average": "O(1)", "worst": "O(n)", "desc": "Explanation..." }}
            }},
            "status": "success"
        }}
        """

        # --- ROUND ROBIN GENERATION STRATEGY ---
        last_error = None
        
        for model_name in MODEL_ROSTER:
            try:
                current_model = genai.GenerativeModel(model_name)
                response = current_model.generate_content(prompt)
                
                clean_text = response.text.replace('```json', '').replace('```', '').strip()
                json_response = json.loads(clean_text)
                
                print(f"✅ Success using: {model_name}") 
                return jsonify(json_response)

            except exceptions.ResourceExhausted:
                print(f"⚠️ Quota exceeded for {model_name}. Switching to next...")
                last_error = "Daily Quota Exceeded on all models."
                continue 
            
            except Exception as e:
                last_error = str(e)
                continue 

        return jsonify({
            "status": "error", 
            "message": f"All available models are busy or out of quota. Last error: {last_error}"
        }), 429

    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

# --- ATTRACTIVE TERMINAL STARTUP ---
if __name__ == '__main__':
    
    app.run(debug=True, port=5000)