import os
import json
import time
import sys
import io
from datetime import datetime
from dotenv import load_dotenv
import google.generativeai as genai
from google.api_core import exceptions
from flask import Flask, request, jsonify, render_template, send_file
from flask_cors import CORS
from fpdf import FPDF, XPos, YPos 
from flask_sqlalchemy import SQLAlchemy

# 1. LOAD ENVIRONMENT VARIABLES
load_dotenv()

# Configure Flask
app = Flask(__name__, static_folder='templates', template_folder='templates')
CORS(app)

# --- DATABASE CONFIGURATION ---
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///codestatic.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# --- DATABASE MODEL (UPDATED FOR FULL HISTORY) ---
class CandidateAssessment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    candidate_id = db.Column(db.String(100), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Code Details
    language = db.Column(db.String(50))
    original_code = db.Column(db.Text)
    final_code = db.Column(db.Text) # Storing fixed code
    
    # Analysis Results (Scalars)
    quality_score = db.Column(db.Integer)
    integrity_status = db.Column(db.String(255))
    plagiarism_status = db.Column(db.String(255))
    compliance_status = db.Column(db.String(50))
    
    # JSON Dumps (Storing complex lists/objects as Text Strings)
    error_table_json = db.Column(db.Text)
    explanation_json = db.Column(db.Text)
    complexity_json = db.Column(db.Text)

    def to_dict(self):
        # Helper to safely load JSON
        def safe_load(json_str):
            try: return json.loads(json_str) if json_str else []
            except: return []

        return {
            "candidate_id": self.candidate_id,
            "timestamp": self.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
            "language": self.language,
            "original_code": self.original_code,
            "final_code": self.final_code,
            "quality_score": self.quality_score,
            "integrity_check": self.integrity_status,
            "plagiarism_check": self.plagiarism_status,
            "compliance_status": self.compliance_status,
            "error_table": safe_load(self.error_table_json),
            "code_explanation": safe_load(self.explanation_json),
            "complexity": safe_load(self.complexity_json)
        }

# Initialize Database
with app.app_context():
    db.create_all()

# 2. SECURELY GET API KEY
api_key = os.getenv("GEMINI_API_KEY")
if api_key:
    genai.configure(api_key=api_key)

# 3. MASSIVE ROUND ROBIN MODEL ROSTER
MODEL_ROSTER = [
    'models/gemini-2.0-flash', 'models/gemini-2.0-flash-001', 'models/gemini-flash-latest',
    'models/gemini-flash-lite-latest', 'models/gemini-2.5-flash', 'models/gemini-2.5-flash-lite',
    'models/gemini-2.5-flash-preview-09-2025', 'models/gemini-2.5-flash-lite-preview-09-2025',
    'models/gemini-2.5-pro', 'models/gemini-pro-latest', 'models/gemini-3-pro-preview',
    'models/deep-research-pro-preview-12-2025', 'models/gemini-2.0-flash-lite',
    'models/gemini-2.0-flash-lite-001', 'models/gemini-2.0-flash-lite-preview',
    'models/gemini-2.0-flash-lite-preview-02-05', 'models/gemini-2.0-flash-exp',
    'models/gemini-exp-1206', 'models/gemma-3-27b-it', 'models/gemma-3-12b-it',
    'models/gemma-3-4b-it', 'models/gemma-3-1b-it', 'models/gemma-3n-e4b-it',
    'models/gemma-3n-e2b-it', 'models/nano-banana-pro-preview' 
]

# --- PROFESSIONAL PDF CLASS ---
class CodeReportPDF(FPDF):
    def header(self):
        self.set_font('Helvetica', 'B', 16)
        self.set_text_color(255, 255, 255)
        self.set_fill_color(220, 53, 69) 
        self.cell(0, 15, 'CodeStatic Evaluation Report', 0, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C', fill=True)
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Helvetica', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 10, f'Page {self.page_no()}/{{nb}} | Generated by CodeStatic AI', 0, new_x=XPos.RIGHT, new_y=YPos.TOP, align='C')

    def chapter_title(self, title):
        self.set_font('Helvetica', 'B', 12)
        self.set_text_color(0, 0, 0)
        self.set_fill_color(240, 240, 240) 
        self.cell(0, 8, f"  {title}", 0, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L', fill=True)
        self.ln(4)

    def status_field(self, label, value):
        self.set_font('Helvetica', 'B', 10)
        self.set_text_color(50, 50, 50)
        self.cell(45, 6, label, 0, new_x=XPos.RIGHT, new_y=YPos.TOP)
        self.set_font('Helvetica', '', 10)
        self.set_text_color(0, 0, 0)
        self.multi_cell(0, 6, value, 0, align='L')
        self.ln(2)

    def code_block(self, code_text):
        self.set_font('Courier', '', 9)
        self.set_fill_color(250, 250, 250)
        self.set_draw_color(200, 200, 200)
        width = self.epw 
        self.multi_cell(width, 5, code_text, border=1, align='L', fill=True)
        self.ln(5)

# --- ROUTES ---

@app.route('/')
def landing_page():
    return render_template('index.html')

@app.route('/logicprobe')
def logic_probe():
    return render_template('tool.html')


# --- NEW: Get List of Candidates for Dropdown ---
@app.route('/api/candidates', methods=['GET'])
def get_candidates():
    with app.app_context():
        # Fetch unique candidate names
        candidates = db.session.query(CandidateAssessment.candidate_id).distinct().all()
        # Convert list of tuples to simple list
        candidate_list = [c[0] for c in candidates]
        return jsonify(candidate_list)

# --- NEW: Get Full History for Specific Candidate ---
@app.route('/api/history/<candidate_name>', methods=['GET'])
def get_candidate_history(candidate_name):
    # Fetch the LATEST record for this candidate
    record = CandidateAssessment.query.filter_by(candidate_id=candidate_name)\
             .order_by(CandidateAssessment.timestamp.desc()).first()
    
    if record:
        return jsonify({"status": "success", "data": record.to_dict()})
    else:
        return jsonify({"status": "error", "message": "Candidate not found"}), 404
# --- NEW: Get List of All Saved Projects for the Modal ---
@app.route('/api/all_projects', methods=['GET'])
def get_all_projects():
    # Fetch ALL records, ordered newest first
    records = CandidateAssessment.query.order_by(CandidateAssessment.timestamp.desc()).all()
    
    # Return a simplified list for the modal display
    project_list = []
    for r in records:
        project_list.append({
            "id": r.id,
            "title": f"{r.candidate_id} ({r.language}) - {r.timestamp.strftime('%Y-%m-%d %H:%M')}",
            "candidate_id": r.candidate_id
        })
    return jsonify(project_list)

# --- NEW: Delete Project Route ---
@app.route('/api/delete_project/<int:project_id>', methods=['DELETE'])
def delete_project(project_id):
    try:
        record = CandidateAssessment.query.get(project_id)
        if record:
            db.session.delete(record)
            db.session.commit()
            return jsonify({"status": "success", "message": f"Project ID {project_id} deleted."})
        return jsonify({"status": "error", "message": "Project not found"}), 404
    except Exception as e:
        db.session.rollback()
        return jsonify({"status": "error", "message": str(e)}), 500

# NOTE: The /api/candidates and /api/history/<candidate_name> routes remain unchanged.

@app.route('/generate_pdf', methods=['POST'])
def generate_pdf():
    try:
        report_data = request.json
        if not report_data or not report_data.get('final_code'):
            return jsonify({"status": "error", "message": "Missing report data."}), 400
        
        pdf = CodeReportPDF()
        pdf.alias_nb_pages()
        pdf.add_page()
        
        pdf.set_font('Helvetica', '', 10)
        pdf.cell(0, 6, f"Target Language: {report_data.get('target_lang', 'N/A')}", 0, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        pdf.cell(0, 6, f"Date: {time.strftime('%Y-%m-%d')}", 0, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        pdf.ln(5)
        
        pdf.chapter_title("2. Compliance & Integrity Status")
        pdf.status_field("Quality Score:", str(report_data.get('quality_score', '--')) + " / 100")
        pdf.status_field("Compliance Status:", report_data.get('compliance_status', 'N/A'))
        pdf.status_field("Integrity Check:", report_data.get('integrity_check', 'N/A'))
        pdf.status_field("Plagiarism Check:", report_data.get('plagiarism_check', 'N/A'))
        pdf.ln(5)

        pdf.chapter_title("3. Candidate Submission (Original Code)")
        pdf.code_block(report_data.get('original_code', 'No code provided.'))

        pdf.chapter_title("4. Standardized & Fixed Code")
        pdf.code_block(report_data.get('final_code', 'Analysis failed.'))

        pdf.chapter_title("5. Critical Error Log")
        pdf.code_block(report_data.get('error_log_text', 'No critical errors found.'))
        
        pdf.chapter_title("6. Complexity Analysis")
        pdf.code_block(report_data.get('time_analysis', 'N/A'))
        pdf.code_block(report_data.get('space_analysis', 'N/A'))

        pdf.chapter_title("7. Line-by-Line Explanation")
        pdf.code_block(report_data.get('explanation_text', 'No detailed explanation provided.'))
        
        pdf_buffer = io.BytesIO(pdf.output())
        pdf_buffer.seek(0)
        download_filename = f"CodeStatic_Report_{time.strftime('%Y%m%d%H%M%S')}.pdf"
        return send_file(pdf_buffer, mimetype="application/pdf", as_attachment=True, download_name=download_filename)
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/ai_chat', methods=['POST'])
def ai_chat():
    try:
        data = request.json
        user_message = data.get('message', '')
        current_code = data.get('code_context', '')
        if not user_message: return jsonify({"status": "error", "message": "No message provided"}), 400

        prompt = f"""
        ACT AS: An Expert AI Coding Assistant for the CodeStatic platform.
        YOUR GOAL: Help the user understand logic, syntax, or concepts. Be concise, friendly, and accurate. Use **only** standard Markdown.
        USER'S CURRENT CODE CONTEXT (For reference only):
        ```{current_code}```
        USER QUESTION: "{user_message}"
        RESPONSE: Provide a direct, helpful answer.
        """
        
        for model_name in MODEL_ROSTER:
            try:
                current_model = genai.GenerativeModel(model_name)
                response = current_model.generate_content(prompt)
                return jsonify({"status": "success", "reply": response.text})
            except: continue 
        return jsonify({"status": "error", "message": "AI services busy."})
    except Exception as e: return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/process_code', methods=['POST'])
def process_code():
    try:
        data = request.json
        source_code = data.get('code', '')
        target_lang = data.get('target_lang', '')
        candidate_id = data.get('candidate_id', 'Unknown')
        
        if not source_code or not target_lang:
            return jsonify({"status": "error", "message": "Missing code or target language"}), 400

        lines = source_code.split('\n')
        numbered_code = "\n".join([f"{i+1} | {line}" for i, line in enumerate(lines)])

        # PROMPT KEPT EXACTLY SAME AS REQUESTED
        prompt = f"""
        ACT AS: The "Supreme Code Architect" and Forensic Debugger.
        TASK: Perform a deep-scan code audit, ruthlessly identify ALL errors, and generate a 100% CORRECT, COMPILABLE solution in {target_lang}.
        
        *** CRITICAL INSTRUCTION ON LINE NUMBERS ***
        The "CANDIDATE INPUT CODE" provided below is PRE-NUMBERED (Format: "LineNumber | Code").
        Use the EXPLICIT line number printed at the start of the line for the error table.
        
        CANDIDATE INPUT CODE:
        ```{numbered_code}```
        
        TARGET LANGUAGE: {target_lang}
        
        ------------------------------------------------------------------------
        MODULE 1: FORENSIC PLAGIARISM & AI DETECTION (ADVANCED SUPERVISED CHECK)
        ------------------------------------------------------------------------
        You are a highly supervised detection engine. Analyze the code for:
        
        1. **AI FINGERPRINT ANALYSIS:**
           - **ChatGPT Style:** Look for "Here is the code", generic variable names (foo, bar, example), or overly verbose comment structures typical of GPT-3.5/4.
           - **Gemini Style:** Look for Google-specific coding patterns, concise "solution-first" structures, or markers typical of PaLM/Gemini training data.
           - **Perplexity/Search AI:** Look for synthesized code that combines multiple distinct styles abruptly (indicating search aggregation).
           
        2. **TOP PROGRAMMING PLATFORM MATCHING:**
           - **LeetCode / HackerRank / GFG / Stack Overflow / Codeforces / CodeChef:** Check logic against the "Canonical Solutions" for known algorithms.
           - **StackOverflow:** Check for "Copy-Paste" patterns (e.g., keeping specific, irrelevant comments or variable names from popular threads).
           
        **PLAGIARISM OUTPUT INSTRUCTION:**
        In the JSON output `plagiarism_check` field, you MUST return a structured detailed string.
        - IF AI GENERATED: "High Match (AI Detected: [Model Name] Pattern)"
        - IF LEETCODE/GFG: "High Match (90%+ Similarity to [Site Name] Standard Solution)"
        - IF ORIGINAL: "Low Match (Original Logic / Custom Implementation)"

        ------------------------------------------------------------------------
        MODULE 2: 23-POINT VALIDATION PROTOCOL
        ------------------------------------------------------------------------
        1. **SYNTAX & COMPILATION (CRITICAL)**
        2. **LOGIC & SEMANTIC ERRORS**
        3. **TYPE & CASTING ERRORS**
        4. **RUNTIME & EXCEPTION PREDICTION**
        5. **LINKER & API ERRORS**
        6. **MEMORY & RESOURCE MANAGEMENT**
        7. **OOP INTEGRITY**
        8. **DSA INTEGRITY**
        9. **SECURITY RISKS**
        10. **CONCURRENCY**
        11. **I/O & FILE HANDLING**
        12. **CONFIGURATION & ENVIRONMENT**
        13. **MATH & ALGORITHMIC ACCURACY**
        14. **INTENT vs IMPLEMENTATION**
        15. **MANDATORY INDENTATION**
        16. **Database Errors**
        17. **Exception Handling**
        18. **Hardware/Driver Issues**
        19. **Network Socket Failures**
        20. **Deprecated API Usage**
        21. **Race Conditions**
        22. **Floating Point Precision**
        23. **Misleading Comments**
        
        INSTRUCTIONS:
        1. **DETECT**: Identify source language.
        2. **ASSESS**: Mental compilation, error mapping, scoring, plagiarism check.
        3. **FIX**: 100% correct code in {target_lang}.
        4. **EXPLAIN**: Line-by-line explanation.
        5. **COMPLEXITY**: Time and Space analysis.
        
        OUTPUT FORMAT (Strict JSON):
        {{
            "detected_language": "String",
            "quality_score": Integer,
            "integrity_check": "String",
            "plagiarism_check": "String", 
            "maintainability_index": Integer,
            "readability_score": Integer,
            "target_complexity": "String",
            "error_table": [ {{ "line": 5, "error": "Desc" }} ],
            "final_code": "String",
            "code_explanation": [ {{ "line": 1, "code": "...", "explanation": "..." }} ],
            "complexity": {{
                "time": {{ "best": "...", "average": "...", "worst": "...", "desc": "..." }},
                "space": {{ "best": "...", "average": "...", "worst": "...", "desc": "..." }}
            }},
            "status": "success",
            "target_lang": "{target_lang}" 
        }}
        """
        
        last_error = None
        for model_name in MODEL_ROSTER:
            try:
                current_model = genai.GenerativeModel(model_name)
                response = current_model.generate_content(prompt)
                clean_text = response.text.replace('```json', '').replace('```', '').strip()
                json_response = json.loads(clean_text)
                
                # Defaults
                json_response["maintainability_index"] = json_response.get("maintainability_index", 50)
                json_response["readability_score"] = json_response.get("readability_score", 75)
                json_response["target_complexity"] = json_response.get("target_complexity", "O(N log N)")
                json_response["quality_score"] = json_response.get("quality_score", 0)

                # --- SAVE FULL HISTORY TO DB ---
                try:
                    new_record = CandidateAssessment(
                        candidate_id=candidate_id,
                        language=target_lang,
                        original_code=source_code,
                        final_code=json_response.get("final_code", ""),
                        quality_score=json_response.get("quality_score", 0),
                        integrity_status=json_response.get("integrity_check", "N/A"),
                        plagiarism_status=json_response.get("plagiarism_check", "N/A"),
                        compliance_status="PASS" if json_response.get("quality_score", 0) > 70 else "FAIL",
                        # Serialize complex lists/dicts to JSON strings for storage
                        error_table_json=json.dumps(json_response.get("error_table", [])),
                        explanation_json=json.dumps(json_response.get("code_explanation", [])),
                        complexity_json=json.dumps(json_response.get("complexity", {}))
                    )
                    db.session.add(new_record)
                    db.session.commit()
                    print(f"‚úÖ [DB] Full History Saved for: {candidate_id}")
                except Exception as db_err:
                    print(f"‚ùå [DB] Save Error: {db_err}")
                # -------------------------------

                return jsonify(json_response)

            except exceptions.ResourceExhausted:
                last_error = "Daily Quota Exceeded."
                continue 
            except Exception as e:
                last_error = str(e)
                continue 

        return jsonify({"status": "error", "message": f"Busy/Quota. {last_error}"}), 429

    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

if __name__ == '__main__':
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

    codestatic_banner = f"""
    {CYAN}{BOLD}
      _____ ____  ____  ____  _____ _____ _____ _____  
     / ____|___ \\/ __ \\/ __ \\|  __ \\_   _|  __ \\_   _|
    | |      __) | |  | |  | | |  __) | | | |   \\| |   
    | |     |__ <| |  | |  | | |  |_ <| | | |    | |   
    | |____/ /__) |  | |  | | |____/ _| |_| |   | |_| 
    \\_____|____/ \\____/ \\____/|_____/|_____|\\____|_____|
    {RESET}
    {YELLOW}  üöÄ SUPREME AI CODE ARCHITECT & FORENSIC DEBUGGER v2.2{RESET}
    """
    print(codestatic_banner)
    print(f"  {GREEN}‚úî  SYSTEM STATUS:{RESET}   {GREEN}ONLINE{RESET}")
    print(f"  {GREEN}‚úî  DATABASE:{RESET}        {GREEN}FULL HISTORY ENABLED (codestatic.db){RESET}")
    print(f"\n  {BOLD}üîó LOCAL SERVER ACCESS:{RESET} {CYAN}http://127.0.0.1:5000{RESET}")
    
    app.run(debug=True, port=5000)